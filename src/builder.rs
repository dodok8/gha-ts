use std::path::{Path, PathBuf};
use std::process::Command;

use anyhow::{Context, Result};
use colored::Colorize;
use tokio::fs;

pub struct WorkflowBuilder {
    input_dir: PathBuf,
    output_dir: PathBuf,
}

impl WorkflowBuilder {
    pub fn new(input_dir: PathBuf, output_dir: PathBuf) -> Self {
        Self {
            input_dir,
            output_dir,
        }
    }

    pub async fn build_all(&self) -> Result<Vec<PathBuf>> {
        // Ensure output directory exists
        fs::create_dir_all(&self.output_dir).await?;

        // Check Node.js installation
        check_node_installed()?;

        // Find all workflow files
        let workflow_files = self.find_workflow_files().await?;

        if workflow_files.is_empty() {
            println!(
                "{} No workflow files found in {}",
                "âš ï¸".yellow(),
                self.input_dir.display()
            );
            return Ok(Vec::new());
        }

        let mut built_files = Vec::new();

        for file in workflow_files {
            match self.build_workflow(&file).await {
                Ok(output_path) => {
                    built_files.push(output_path);
                }
                Err(e) => {
                    eprintln!(
                        "{} Failed to build {}: {}",
                        "âŒ".red(),
                        file.display(),
                        e
                    );
                }
            }
        }

        Ok(built_files)
    }

    async fn find_workflow_files(&self) -> Result<Vec<PathBuf>> {
        let mut files = Vec::new();
        let mut entries = fs::read_dir(&self.input_dir).await?;

        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if let Some(ext) = path.extension() {
                if ext == "ts" && !path.to_string_lossy().contains(".d.ts") {
                    files.push(path);
                }
            }
        }

        Ok(files)
    }

    pub async fn build_workflow(&self, workflow_path: &Path) -> Result<PathBuf> {
        println!(
            "{} Building {}...",
            "ðŸ”¨".cyan(),
            workflow_path.file_name().unwrap_or_default().to_string_lossy()
        );

        // Execute the TypeScript file
        let json_output = execute_workflow(workflow_path)?;

        // Parse and convert to YAML
        let yaml_content = json_to_yaml(&json_output)?;

        // Validate YAML
        validate_yaml(&yaml_content)?;

        // Generate output filename
        let stem = workflow_path
            .file_stem()
            .ok_or_else(|| anyhow::anyhow!("Invalid workflow file name"))?
            .to_string_lossy();

        let output_path = self.output_dir.join(format!("{}.yml", stem));

        // Check if content changed
        if should_write_file(&output_path, &yaml_content).await? {
            // Add header comment
            let final_content = format!(
                "# Auto-generated by gha-ts\n# Do not edit manually - Edit {} instead\n# Generated at: {}\n\n{}",
                workflow_path.display(),
                chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ"),
                yaml_content
            );

            fs::write(&output_path, final_content).await?;
            println!(
                "   {} Wrote {}",
                "âœ…".green(),
                output_path.file_name().unwrap_or_default().to_string_lossy()
            );
        } else {
            println!(
                "   {} {} (unchanged)",
                "â­ï¸".dimmed(),
                output_path.file_name().unwrap_or_default().to_string_lossy()
            );
        }

        Ok(output_path)
    }
}

fn check_node_installed() -> Result<()> {
    Command::new("node")
        .arg("--version")
        .output()
        .context("Node.js is not installed. Please install Node.js to build workflows.")?;
    Ok(())
}

fn execute_workflow(workflow_path: &Path) -> Result<String> {
    // Try tsx first, then ts-node
    let output = Command::new("npx")
        .args(["tsx", workflow_path.to_str().unwrap()])
        .output();

    match output {
        Ok(output) if output.status.success() => {
            Ok(String::from_utf8(output.stdout)?)
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(anyhow::anyhow!(
                "Failed to execute workflow:\n{}",
                stderr
            ))
        }
        Err(_) => {
            // Try ts-node as fallback
            let output = Command::new("npx")
                .args(["ts-node", workflow_path.to_str().unwrap()])
                .output()
                .context("Neither tsx nor ts-node is available")?;

            if output.status.success() {
                Ok(String::from_utf8(output.stdout)?)
            } else {
                let stderr = String::from_utf8_lossy(&output.stderr);
                Err(anyhow::anyhow!(
                    "Failed to execute workflow:\n{}",
                    stderr
                ))
            }
        }
    }
}

fn json_to_yaml(json_str: &str) -> Result<String> {
    let json_value: serde_json::Value = serde_json::from_str(json_str)
        .context("Invalid JSON output from workflow")?;

    let yaml_str = serde_yaml::to_string(&json_value)?;

    Ok(yaml_str)
}

fn validate_yaml(yaml: &str) -> Result<()> {
    let value: serde_yaml::Value = serde_yaml::from_str(yaml)
        .context("Invalid YAML syntax")?;

    // Basic GitHub Actions schema validation
    let mapping = value.as_mapping()
        .ok_or_else(|| anyhow::anyhow!("Workflow must be a YAML mapping"))?;

    // Check for required 'on' field
    if !mapping.contains_key(serde_yaml::Value::String("on".to_string())) {
        return Err(anyhow::anyhow!("Workflow missing required 'on' field"));
    }

    // Check for required 'jobs' field
    if !mapping.contains_key(serde_yaml::Value::String("jobs".to_string())) {
        return Err(anyhow::anyhow!("Workflow missing required 'jobs' field"));
    }

    Ok(())
}

async fn should_write_file(path: &Path, new_content: &str) -> Result<bool> {
    if !path.exists() {
        return Ok(true);
    }

    let old_content = fs::read_to_string(path).await?;

    // Compare without the header (first 4 lines are comments)
    let old_lines: Vec<&str> = old_content.lines().skip(4).collect();
    let old_stripped = old_lines.join("\n");

    Ok(old_stripped.trim() != new_content.trim())
}

pub async fn ensure_workflows_dir() -> Result<PathBuf> {
    let dir = PathBuf::from(".github/workflows");
    fs::create_dir_all(&dir).await?;
    Ok(dir)
}

// Add chrono dependency for timestamp
mod chrono {
    pub struct Utc;
    impl Utc {
        pub fn now() -> DateTime {
            DateTime
        }
    }
    pub struct DateTime;
    impl DateTime {
        pub fn format(&self, _fmt: &str) -> String {
            // Simple implementation - in production use chrono crate
            let now = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs();
            format!("{}", now)
        }
    }
}
