pub mod templates;
pub mod types;

use std::collections::HashSet;
use std::path::{Path, PathBuf};

use anyhow::Result;
use tokio::fs;

use crate::cache::Cache;
use crate::fetcher::GitHubFetcher;

use self::templates::{BASE_TYPES_TEMPLATE, GET_ACTION_BASE_TEMPLATE, GET_ACTION_RUNTIME_TEMPLATE};
use self::types::generate_type_definition;

pub struct TypeGenerator {
    fetcher: GitHubFetcher,
    output_dir: PathBuf,
}

impl TypeGenerator {
    pub fn new(cache: Cache, output_dir: PathBuf) -> Self {
        Self {
            fetcher: GitHubFetcher::new(cache),
            output_dir,
        }
    }

    pub async fn generate_types_for_refs(
        &self,
        action_refs: &HashSet<String>,
    ) -> Result<Vec<PathBuf>> {
        fs::create_dir_all(&self.output_dir).await?;

        let mut generated_files = Vec::new();

        // Generate base types first
        let base_path = self.generate_base_types().await?;
        generated_files.push(base_path);

        for action_ref in action_refs {
            match self.generate_type_for_ref(action_ref).await {
                Ok(path) => {
                    generated_files.push(path);
                }
                Err(e) => {
                    eprintln!("Failed to generate types for {}: {}", action_ref, e);
                }
            }
        }

        // Generate index.d.ts
        self.generate_index_file(&generated_files, action_refs)
            .await?;

        Ok(generated_files)
    }

    async fn generate_base_types(&self) -> Result<PathBuf> {
        let content = BASE_TYPES_TEMPLATE.to_string();

        let file_path = self.output_dir.join("base.d.ts");
        fs::write(&file_path, content).await?;

        Ok(file_path)
    }

    async fn generate_type_for_ref(&self, action_ref: &str) -> Result<PathBuf> {
        let metadata = self.fetcher.fetch_action_metadata(action_ref).await?;
        let type_def = generate_type_definition(action_ref, &metadata);

        let filename = action_ref_to_filename(action_ref);
        let file_path = self.output_dir.join(&filename);

        fs::write(&file_path, type_def).await?;

        Ok(file_path)
    }

    async fn generate_index_file(
        &self,
        generated_files: &[PathBuf],
        action_refs: &HashSet<String>,
    ) -> Result<()> {
        let mut exports = Vec::new();

        for file_path in generated_files {
            if let Some(stem) = file_path.file_stem() {
                // Remove .d suffix for TypeScript imports (e.g., "base.d" -> "base")
                let module_name = stem.to_string_lossy();
                let clean_name = module_name.strip_suffix(".d").unwrap_or(&module_name);
                exports.push(format!("export * from './{}';", clean_name));
            }
        }

        let mut sorted_refs: Vec<&String> = action_refs.iter().collect();
        sorted_refs.sort();

        let mut import_lines = Vec::new();
        import_lines.push("import type { JobStep } from './base';".to_string());

        for action_ref in &sorted_refs {
            let interface_name = action_ref_to_interface_name(action_ref);
            let module_name = action_ref_to_module_name(action_ref);
            import_lines.push(format!(
                "import type {{ {}Inputs }} from './{}';",
                interface_name, module_name
            ));
        }

        let mut overloads = String::new();
        for action_ref in &sorted_refs {
            let interface_name = action_ref_to_interface_name(action_ref);
            overloads.push_str(&format!(
                r#"export function getAction(
    ref: '{}'
): (config?: {{
    name?: string;
    with?: {}Inputs;
    id?: string;
    if?: string;
    env?: Record<string, string>;
}}) => JobStep;
"#,
                action_ref, interface_name
            ));
        }

        let index_content = format!(
            "// Auto-generated by gha-ts\n// Do not edit manually\n\n{}\n\n{}\n{}\n{}\n",
            import_lines.join("\n"),
            overloads,
            GET_ACTION_BASE_TEMPLATE,
            exports.join("\n")
        );

        let index_path = self.output_dir.join("index.d.ts");
        fs::write(index_path, index_content).await?;

        let runtime_path = self.output_dir.join("index.ts");
        fs::write(runtime_path, GET_ACTION_RUNTIME_TEMPLATE).await?;

        Ok(())
    }
}

pub fn action_ref_to_filename(action_ref: &str) -> String {
    action_ref
        .replace(['/', '@', '.'], "-")
        + ".d.ts"
}

pub fn action_ref_to_interface_name(action_ref: &str) -> String {
    // "actions/checkout@v4" -> "ActionsCheckoutV4"
    action_ref
        .split(['/', '@', '-', '.'])
        .filter(|s| !s.is_empty())
        .map(|s| {
            let mut chars = s.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

fn action_ref_to_module_name(action_ref: &str) -> String {
    action_ref_to_filename(action_ref)
        .trim_end_matches(".d.ts")
        .to_string()
}

pub async fn ensure_generated_dir(path: &Path) -> Result<PathBuf> {
    let dir = path.to_path_buf();
    fs::create_dir_all(&dir).await?;
    Ok(dir)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_action_ref_to_filename() {
        assert_eq!(
            action_ref_to_filename("actions/checkout@v4"),
            "actions-checkout-v4.d.ts"
        );
        assert_eq!(
            action_ref_to_filename("owner/repo/path@main"),
            "owner-repo-path-main.d.ts"
        );
    }

    #[test]
    fn test_action_ref_to_interface_name() {
        assert_eq!(
            action_ref_to_interface_name("actions/checkout@v4"),
            "ActionsCheckoutV4"
        );
        assert_eq!(
            action_ref_to_interface_name("actions/setup-node@v4"),
            "ActionsSetupNodeV4"
        );
    }
}
