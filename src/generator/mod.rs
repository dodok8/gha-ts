pub mod templates;
pub mod types;

use std::collections::HashSet;
use std::path::{Path, PathBuf};

use anyhow::Result;
use tokio::fs;

use crate::cache::Cache;
use crate::fetcher::GitHubFetcher;

use self::templates::{
    BASE_TYPES_TEMPLATE, GET_ACTION_BASE_RUNTIME_TEMPLATE, GET_ACTION_RUNTIME_IMPL_TEMPLATE,
};
use self::types::generate_type_definition;

pub struct TypeGenerator {
    fetcher: GitHubFetcher,
    output_dir: PathBuf,
}

impl TypeGenerator {
    pub fn new(cache: Cache, output_dir: PathBuf) -> Self {
        Self {
            fetcher: GitHubFetcher::new(cache),
            output_dir,
        }
    }

    pub async fn generate_types_for_refs(
        &self,
        action_refs: &HashSet<String>,
    ) -> Result<Vec<PathBuf>> {
        fs::create_dir_all(&self.output_dir).await?;

        let mut generated_files = Vec::new();

        // Generate base types first
        let base_path = self.generate_base_types().await?;
        generated_files.push(base_path);

        let mut action_infos = Vec::new();

        for action_ref in action_refs {
            match self.generate_type_for_ref(action_ref).await {
                Ok((path, info)) => {
                    generated_files.push(path);
                    action_infos.push(info);
                }
                Err(e) => {
                    eprintln!("Failed to generate types for {}: {}", action_ref, e);
                }
            }
        }

        // Generate index.ts only
        self.generate_index_file(&action_infos).await?;

        Ok(generated_files)
    }

    async fn generate_base_types(&self) -> Result<PathBuf> {
        let content = BASE_TYPES_TEMPLATE.to_string();

        let file_path = self.output_dir.join("base.d.ts");
        fs::write(&file_path, content).await?;

        Ok(file_path)
    }

    async fn generate_type_for_ref(&self, action_ref: &str) -> Result<(PathBuf, ActionTypeInfo)> {
        let metadata = self.fetcher.fetch_action_metadata(action_ref).await?;
        let type_def = generate_type_definition(action_ref, &metadata);

        let interface_name = action_ref_to_interface_name(action_ref);
        let module_name = action_ref_to_module_name(action_ref);
        let has_outputs = metadata
            .outputs
            .as_ref()
            .map(|outputs| !outputs.is_empty())
            .unwrap_or(false);

        let filename = action_ref_to_filename(action_ref);
        let file_path = self.output_dir.join(&filename);

        fs::write(&file_path, type_def).await?;

        Ok((
            file_path,
            ActionTypeInfo {
                action_ref: action_ref.to_string(),
                interface_name,
                module_name,
                has_outputs,
            },
        ))
    }

    async fn generate_index_file(&self, action_infos: &[ActionTypeInfo]) -> Result<()> {
        let mut sorted_infos = action_infos.to_vec();
        sorted_infos.sort_by(|left, right| left.action_ref.cmp(&right.action_ref));

        let mut import_lines = Vec::new();
        import_lines.push("import type { JobStep } from './base';".to_string());

        for info in &sorted_infos {
            import_lines.push(format!(
                "import type {{ {}Inputs }} from './{}';",
                info.interface_name, info.module_name
            ));
        }

        let mut overloads = String::new();
        for info in &sorted_infos {
            overloads.push_str(&format!(
                r#"export function getAction(
    ref: '{}'
): (config?: {{
    name?: string;
    with?: {}Inputs;
    id?: string;
    if?: string;
    env?: Record<string, string>;
}}) => JobStep;
"#,
                info.action_ref, info.interface_name
            ));
        }

        let mut export_lines = Vec::new();
        export_lines.push(
            "export type { JobStep, Job, Service, Container, Permissions, WorkflowTrigger, \
ScheduleTrigger, WorkflowDispatchInput, WorkflowOn, Workflow } from './base';"
                .to_string(),
        );
        for info in &sorted_infos {
            if info.has_outputs {
                export_lines.push(format!(
                    "export type {{ {}Inputs, {}Outputs }} from './{}';",
                    info.interface_name, info.interface_name, info.module_name
                ));
            } else {
                export_lines.push(format!(
                    "export type {{ {}Inputs }} from './{}';",
                    info.interface_name, info.module_name
                ));
            }
        }

        let runtime_content = format!(
            "// Auto-generated by gha-ts\n// Do not edit manually\n\n{}\n\n{}\n{}\n{}\n\n{}\n",
            import_lines.join("\n"),
            overloads,
            GET_ACTION_BASE_RUNTIME_TEMPLATE,
            GET_ACTION_RUNTIME_IMPL_TEMPLATE,
            export_lines.join("\n")
        );

        let runtime_path = self.output_dir.join("index.ts");
        fs::write(runtime_path, runtime_content).await?;

        Ok(())
    }
}

#[derive(Clone)]
struct ActionTypeInfo {
    action_ref: String,
    interface_name: String,
    module_name: String,
    has_outputs: bool,
}

pub fn action_ref_to_filename(action_ref: &str) -> String {
    action_ref.replace(['/', '@', '.'], "-") + ".d.ts"
}

pub fn action_ref_to_interface_name(action_ref: &str) -> String {
    // "actions/checkout@v4" -> "ActionsCheckoutV4"
    action_ref
        .split(['/', '@', '-', '.'])
        .filter(|s| !s.is_empty())
        .map(|s| {
            let mut chars = s.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

fn action_ref_to_module_name(action_ref: &str) -> String {
    action_ref_to_filename(action_ref)
        .trim_end_matches(".d.ts")
        .to_string()
}

pub async fn ensure_generated_dir(path: &Path) -> Result<PathBuf> {
    let dir = path.to_path_buf();
    fs::create_dir_all(&dir).await?;
    Ok(dir)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_action_ref_to_filename() {
        assert_eq!(
            action_ref_to_filename("actions/checkout@v4"),
            "actions-checkout-v4.d.ts"
        );
        assert_eq!(
            action_ref_to_filename("owner/repo/path@main"),
            "owner-repo-path-main.d.ts"
        );
    }

    #[test]
    fn test_action_ref_to_interface_name() {
        assert_eq!(
            action_ref_to_interface_name("actions/checkout@v4"),
            "ActionsCheckoutV4"
        );
        assert_eq!(
            action_ref_to_interface_name("actions/setup-node@v4"),
            "ActionsSetupNodeV4"
        );
    }
}
