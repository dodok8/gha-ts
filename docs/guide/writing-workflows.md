# Writing Workflows

This guide explains how to write type-safe GitHub Actions workflows using gaji.

::: tip Standalone TypeScript Files
Workflow files generated by gaji can run standalone. You can execute them directly with any TypeScript runtime (tsx, ts-node, Deno) to output the workflow JSON. Convenient for debugging and inspection.
:::

## Basic Structure

A gaji workflow consists of three main components:

1. **Actions**: Imported using `getAction()`
2. **Jobs**: Created using the `Job` class
3. **Workflows**: Created using the `Workflow` class

```ts twoslash
// @filename: workflows/example.ts
// ---cut---
import { getAction, Job, Workflow } from "../generated/index.js";

// 1. Import actions
const checkout = getAction("actions/checkout@v5");

// 2. Create jobs
const build = new Job("ubuntu-latest")
  .addStep(checkout({}));

// 3. Create workflow
const workflow = new Workflow({
  name: "CI",
  on: { push: { branches: ["main"] } },
}).addJob("build", build);

// 4. Build to YAML
workflow.build("ci");
```

## Using Actions

### Run gaji dev

```bash
gaji dev --watch
```

### Importing Actions

Import actions using `getAction()`:

```typescript
const checkout = getAction("actions/checkout@v5");
const setupNode = getAction("actions/setup-node@v4");
const cache = getAction("actions/cache@v4");
```

### Using Actions with Type Safety

Actions return a function that accepts configuration:

```typescript
const step = checkout({
  name: "Checkout code",
  with: {
    // ✅ Full autocomplete for all inputs!
    repository: "owner/repo",
    ref: "main",
    token: "${{ secrets.GITHUB_TOKEN }}",
    "fetch-depth": 0,
  },
});
```

Your editor will provide:
- ✅ Autocomplete for all action inputs
- ✅ Type checking
- ✅ Documentation from action.yml
- ✅ Default values shown

## Creating Jobs

Jobs are created using the `Job` class:

```typescript
const job = new Job("ubuntu-latest");
```

### Supported Runners

```typescript
// Ubuntu
new Job("ubuntu-latest")
new Job("ubuntu-22.04")
new Job("ubuntu-20.04")

// macOS
new Job("macos-latest")
new Job("macos-13")
new Job("macos-12")

// Windows
new Job("windows-latest")
new Job("windows-2022")
new Job("windows-2019")

// Self-hosted
new Job("self-hosted")
new Job(["self-hosted", "linux", "x64"])
```

### Adding Steps

Steps can be added using `.addStep()`:

```typescript
const job = new Job("ubuntu-latest")
  // Action step
  .addStep(checkout({
    name: "Checkout",
  }))

  // Run command
  .addStep({
    name: "Build",
    run: "npm run build",
  })

  // Multi-line command
  .addStep({
    name: "Install dependencies",
    run: `
      npm ci
      npm run build
      npm test
    `.trim(),
  })

  // With environment variables
  .addStep({
    name: "Deploy",
    run: "npm run deploy",
    env: {
      NODE_ENV: "production",
      API_KEY: "${{ secrets.API_KEY }}",
    },
  })

  // Conditional step
  .addStep({
    name: "Upload artifacts",
    if: "success()",
    run: "npm run upload",
  });
```

## Creating Workflows

### Basic Workflow

```typescript
const workflow = new Workflow({
  name: "CI",
  on: {
    push: {
      branches: ["main"],
    },
  },
}).addJob("build", buildJob);

workflow.build("ci");
```

### Trigger Events

#### Push

```typescript
on: {
  push: {
    branches: ["main", "develop"],
    tags: ["v*"],
    paths: ["src/**", "tests/**"],
  },
}
```

#### Pull Request

```typescript
on: {
  pull_request: {
    branches: ["main"],
    types: ["opened", "synchronize", "reopened"],
  },
}
```

#### Schedule (Cron)

```typescript
on: {
  schedule: [
    { cron: "0 0 * * *" },  // Daily at midnight
  ],
}
```

#### Multiple Triggers

```typescript
on: {
  push: { branches: ["main"] },
  pull_request: { branches: ["main"] },
  workflow_dispatch: {},  // Manual trigger
}
```

### Multiple Jobs

```typescript
const test = new Job("ubuntu-latest")
  .addStep(checkout({}))
  .addStep({ run: "npm test" });

const build = new Job("ubuntu-latest")
  .addStep(checkout({}))
  .addStep({ run: "npm run build" });

const workflow = new Workflow({
  name: "CI",
  on: { push: { branches: ["main"] } },
})
  .addJob("test", test)
  .addJob("build", build);
```

### Job Dependencies

Use `.needs()` to create job dependencies:

```typescript
const test = new Job("ubuntu-latest")
  .addStep({ run: "npm test" });

const deploy = new Job("ubuntu-latest")
  .needs(["test"])  // Wait for test job
  .addStep({ run: "npm run deploy" });

const workflow = new Workflow({
  name: "Deploy",
  on: { push: { branches: ["main"] } },
})
  .addJob("test", test)
  .addJob("deploy", deploy);
```

## Matrix Builds

Create matrix builds for testing across multiple versions:

```typescript
const test = new Job("${{ matrix.os }}")
  .strategy({
    matrix: {
      os: ["ubuntu-latest", "macos-latest", "windows-latest"],
      node: ["18", "20", "22"],
    },
  })
  .addStep(checkout({}))
  .addStep(setupNode({
    with: {
      "node-version": "${{ matrix.node }}",
    },
  }))
  .addStep({ run: "npm test" });
```

## Composite Actions

Create reusable [composite actions](https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action):

```ts twoslash
// @filename: workflows/example.ts
// ---cut---
import { CompositeAction, getAction } from "../generated/index.js";

const checkout = getAction("actions/checkout@v5");

const myAction = new CompositeAction({
  name: "My Action",
  description: "Reusable action",
  inputs: {
    version: {
      description: "Version to install",
      required: true,
    },
  },
})
  .addStep(checkout({}))
  .addStep({
    run: "echo Installing version ${{ inputs.version }}",
  });

myAction.build("my-action");
```

This generates `action.yml` in your repository.

## CompositeJob

Create reusable jobs using `CompositeJob`:

```ts twoslash
// @filename: workflows/example.ts
// ---cut---
import { CompositeJob, getAction, Workflow } from "../generated/index.js";

const checkout = getAction("actions/checkout@v5");
const setupNode = getAction("actions/setup-node@v4");

// Define a reusable job class
class NodeTestJob extends CompositeJob {
  constructor(nodeVersion: string) {
    super("ubuntu-latest");

    this
      .addStep(checkout({
        name: "Checkout code",
      }))
      .addStep(setupNode({
        name: `Setup Node.js ${nodeVersion}`,
        with: {
          "node-version": nodeVersion,
          cache: "npm",
        },
      }))
      .addStep({
        name: "Install dependencies",
        run: "npm ci",
      })
      .addStep({
        name: "Run tests",
        run: "npm test",
      });
  }
}

// Use in workflow
const workflow = new Workflow({
  name: "Test Matrix",
  on: { push: { branches: ["main"] } },
})
  .addJob("test-node-18", new NodeTestJob("18"))
  .addJob("test-node-20", new NodeTestJob("20"))
  .addJob("test-node-22", new NodeTestJob("22"));

workflow.build("test-matrix");
```

## Full Example: Per-environment Deploy with CallJob

A pattern where you create a reusable workflow (`workflow_call`) and call it per environment with `CallJob`.

First, write a reusable workflow containing the deploy steps. It receives the environment name via `workflow_call` inputs.

```ts twoslash
// @noErrors
// @filename: workflows/publish.ts
// ---cut---
import { getAction, Job, Workflow } from "../generated/index.js";

const checkout = getAction("actions/checkout@v5");
const setupNode = getAction("actions/setup-node@v4");

const publish = new Job("ubuntu-latest")
  .addStep(checkout({ name: "Checkout" }))
  .addStep(setupNode({
    name: "Setup Node.js",
    with: { "node-version": "20", cache: "npm" },
  }))
  .addStep({ name: "Install dependencies", run: "npm ci" })
  .addStep({ name: "Build", run: "npm run build" })
  .addStep({
    name: "Publish",
    run: "npm run publish:${{ inputs.environment }}",
    env: {
      DEPLOY_TOKEN: "${{ secrets.DEPLOY_TOKEN }}",
    },
  });

const workflow = new Workflow({
  name: "Publish",
  on: {
    workflow_call: {
      inputs: {
        environment: {
          description: "Target environment (alpha, staging, live)",
          required: true,
          type: "choice",
          options: ["alpha", "staging", "live"],
        },
      },
      secrets: {
        DEPLOY_TOKEN: { required: true },
      },
    },
  },
}).addJob("publish", publish);

workflow.build("publish");
```

Next, use `CallJob` to call this workflow for each environment. Use `needs` to enforce the order alpha → staging → live:

```ts twoslash
// @noErrors
// @filename: workflows/release.ts
// ---cut---
import { CallJob, Workflow } from "../generated/index.js";

const alpha = new CallJob("./.github/workflows/publish.yml")
  .with({ environment: "alpha" })
  .secrets("inherit");

const staging = new CallJob("./.github/workflows/publish.yml")
  .with({ environment: "staging" })
  .secrets("inherit")
  .needs(["publish-alpha"]);

const live = new CallJob("./.github/workflows/publish.yml")
  .with({ environment: "live" })
  .secrets("inherit")
  .needs(["publish-staging"]);

const workflow = new Workflow({
  name: "Release",
  on: { push: { tags: ["v*"] } },
})
  .addJob("publish-alpha", alpha)
  .addJob("publish-staging", staging)
  .addJob("publish-live", live);

workflow.build("release");
```

The benefit of this structure is that deploy logic lives in `publish.yml` alone. When you need to change deploy steps, just update `publish.ts` and it applies to all environments.

## Docker Actions

Create [Docker container actions](https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action). The `runs.using` is `"docker"`, and you specify an image and optional entrypoint.

```ts twoslash
// @noErrors
// @filename: workflows/example.ts
// ---cut---
import { DockerAction } from "../generated/index.js";

const action = new DockerAction(
  {
    name: "Lint with Super-Linter",
    description: "Run Super-Linter in a Docker container",
    inputs: {
      args: {
        description: "Linter arguments",
        required: false,
      },
    },
  },
  {
    using: "docker",
    image: "Dockerfile",
    entrypoint: "entrypoint.sh",
    args: ["--config", ".lintrc"],
    env: {
      DEFAULT_BRANCH: "main",
    },
  },
);

action.build("super-linter");
```

This generates `.github/actions/super-linter/action.yml`. Use `CallAction.from()` to reference it in a workflow.

To use a Docker Hub image directly, prefix the `image` with `docker://`:

```typescript
{
  using: "docker",
  image: "docker://alpine:3.19",
}
```

## Environment Variables

### Workflow-level

```typescript
const workflow = new Workflow({
  name: "CI",
  on: { push: { branches: ["main"] } },
  env: {
    NODE_ENV: "production",
  },
});
```

### Job-level

```typescript
const job = new Job("ubuntu-latest")
  .env({
    DATABASE_URL: "${{ secrets.DATABASE_URL }}",
  });
```

### Step-level

```typescript
.addStep({
  run: "npm run deploy",
  env: {
    API_KEY: "${{ secrets.API_KEY }}",
  },
})
```

## Outputs

### Typed Step Outputs

When you provide an `id` to an action step, gaji returns an `ActionStep` with typed output properties:

```typescript
const checkout = getAction("actions/checkout@v5");

// Providing id gives typed outputs
const step = checkout({ id: "my-checkout" });
step.outputs.ref     // "${{ steps.my-checkout.outputs.ref }}"
step.outputs.commit  // "${{ steps.my-checkout.outputs.commit }}"

const job = new Job("ubuntu-latest")
  .addStep(step)
  .addStep({ run: `echo ${step.outputs.ref}` });
```

### Passing Outputs Between Jobs

Use `jobOutputs()` to create typed references for downstream jobs. It reads the job's `.outputs()` keys and generates `${{ needs.<jobId>.outputs.<key> }}` expressions:

```typescript
const checkout = getAction("actions/checkout@v5");
const step = checkout({ id: "my-checkout" });

// Define job with typed outputs
const build = new Job("ubuntu-latest")
  .addStep(step)
  .outputs({ ref: step.outputs.ref, sha: step.outputs.commit });

// Create typed references for downstream jobs
const buildOutputs = jobOutputs("build", build);
// buildOutputs.ref → "${{ needs.build.outputs.ref }}"
// buildOutputs.sha → "${{ needs.build.outputs.sha }}"

const deploy = new Job("ubuntu-latest")
  .needs("build")
  .addStep({ run: `deploy --ref ${buildOutputs.ref}` });

const workflow = new Workflow({
  name: "CI",
  on: { push: { branches: ["main"] } },
})
  .addJob("build", build)
  .addJob("deploy", deploy);
```

You can also use manually defined outputs (e.g., from `run` steps that write to `$GITHUB_OUTPUT`):

```typescript
const setup = new Job("ubuntu-latest")
  .addStep({
    id: "version",
    run: 'echo "value=1.0.0" >> $GITHUB_OUTPUT',
  })
  .outputs({
    version: "${{ steps.version.outputs.value }}",
  });

const setupOutputs = jobOutputs("setup", setup);

const deploy = new Job("ubuntu-latest")
  .needs("setup")
  .addStep({ run: `deploy --version ${setupOutputs.version}` });
```

## Tips

### 1. Use Watch Mode

Always use `gaji dev --watch` during development to automatically generate types for new actions.

### 2. Review Generated YAML

Always review the generated YAML before committing to ensure correctness.

### 3. Type Safety

Take advantage of TypeScript's type checking:

```typescript
// ❌ Type error - unknown property key
setupNode({
  with: {
    "node-versoin": "20",  // Typo in key name! ❌
  },
});

// ❌ Type error - wrong type
setupNode({
  with: {
    "node-version": 20,  // Should be string! ❌
  },
});

// ✅ Correct
setupNode({
  with: {
    "node-version": "20",  // ✅ Correct key and type
    cache: "npm",
  },
});
```

**Note**: While gaji provides type safety for property keys and types, it cannot validate string values (e.g., `cache: "npn"` vs `cache: "npm"`) at compile time. Always review generated YAML to catch such typos.

## Known Limitations

### `getAction()` Requires String Literals

gaji statically analyzes your TypeScript files to extract action references **without executing them**. This means `getAction()` only works with string literals:

```typescript
// ✅ Works - string literal
const checkout = getAction("actions/checkout@v5");

// ❌ Does NOT work - variable reference
const ref = "actions/checkout@v5";
const checkout = getAction(ref);

// ❌ Does NOT work - template literal
const checkout = getAction(`actions/checkout@v${version}`);

// ❌ Does NOT work - object property
const checkout = getAction(config.checkoutRef);
```

If gaji cannot detect the action reference, it won't fetch the `action.yml` or generate types for that action. Always pass the full `owner/repo@version` string directly.

### String Escaping in YAML Output

Since gaji converts JavaScript strings to YAML, characters that are already escaped in JavaScript may be double-escaped in the output. For example:

```typescript
// In TypeScript, \n is a newline character
.addStep({ run: "echo \"hello\nworld\"" })
```

The JS string contains a literal newline, which YAML will handle correctly. However, if you actually want the literal `\n` characters in the YAML output (e.g., for multiline `echo`), you need to double-escape:

```typescript
// Double-escape to preserve the literal \n in YAML
.addStep({ run: "echo hello\\nworld" })
```

**Tip**: For multi-line commands, prefer template literals instead of escape sequences:

```typescript
.addStep({
  run: `
    echo hello
    echo world
  `.trim(),
})
```

## Next Steps

- Learn about [Configuration](./configuration.md)
- See [Examples](/examples/simple-ci)
- Check the [API Reference](/reference/api)
